// Generated by CoffeeScript 1.6.3
(function() {
  var check_compatability, check_noisy, check_understands, count, flag, flag1, flag2, flag3, generate_random_groups, groups, initialJSON, json, print_results, printable_list, reset_input, shuffle, stringified, student_count,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  initialJSON = require('./students.json');

  stringified = JSON.stringify(initialJSON);

  groups = [];

  json = JSON.parse(stringified);

  student_count = json.students.length;

  shuffle = function(source_array) {
    var i, item, j, temp, _i, _len;
    for (i = _i = 0, _len = source_array.length; _i < _len; i = ++_i) {
      item = source_array[i];
      j = i + Math.floor(Math.random() * source_array.length - i);
      temp = source_array[j];
      source_array[j] = source_array[i];
      source_array[i] = temp;
    }
    return source_array;
  };

  print_results = function() {
    /*
    Prints remaining students, members of each group
    */

    var group, i, _i, _len, _results;
    console.log('Unassigned students remaining: ' + printable_list(json.students));
    _results = [];
    for (i = _i = 0, _len = groups.length; _i < _len; i = ++_i) {
      group = groups[i];
      _results.push(console.log('Group ' + (i + 1) + ': ' + printable_list(groups[i])));
    }
    return _results;
  };

  printable_list = function(input_group) {
    /*
    Given list of student objects, returns string of names
    */

    var names, student, _i, _len;
    names = [];
    for (_i = 0, _len = input_group.length; _i < _len; _i++) {
      student = input_group[_i];
      names.push(student.name);
    }
    return JSON.stringify(names);
  };

  generate_random_groups = function() {
    /*
    Populates groups randomly
    */

    var group, _i, _ref, _results;
    for (_i = 0, _ref = json.groups; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
      groups.push([]);
    }
    _results = [];
    while (json.students.length > 0) {
      _results.push((function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = groups.length; _j < _len; _j++) {
          group = groups[_j];
          if (json.students.length > 0) {
            group.push(json.students[0]);
            _results1.push(json.students.splice(0, 1));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  reset_input = function() {
    /*
    Generates a fresh, shuffled array of students
    */

    groups = [];
    json = JSON.parse(stringified);
    return json.students = shuffle(json.students);
  };

  check_noisy = function() {
    /*
    Checks each group for total count of noisy children, returns false if any one exceeds two, true otherwise.
    */

    var i, noisy_count, student, _i, _j, _len, _ref, _ref1;
    noisy_count = [];
    for (i = _i = 0, _ref = json.groups; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      noisy_count.push(0);
      _ref1 = groups[i];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        student = _ref1[_j];
        if (student.noisy) {
          noisy_count[i] += 1;
        }
      }
      if (noisy_count[i] > 2) {
        return false;
      }
    }
    return true;
  };

  check_compatability = function() {
    /*
    Checks each group to see if anyone will fight
    */

    var entry, group, i, incompatable_list, student, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    for (i = _i = 0, _len = groups.length; _i < _len; i = ++_i) {
      group = groups[i];
      incompatable_list = [];
      for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
        student = group[_j];
        _ref = student.fights_with;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          entry = _ref[_k];
          incompatable_list.push(entry);
        }
      }
      for (_l = 0, _len3 = group.length; _l < _len3; _l++) {
        student = group[_l];
        if (_ref1 = student.name, __indexOf.call(incompatable_list, _ref1) >= 0) {
          return false;
        }
      }
    }
    return true;
  };

  check_understands = function() {
    /*
    Check if at least one student per group who understands
    */

    var group, i, student, understand_count, _i, _j, _len, _len1;
    for (i = _i = 0, _len = groups.length; _i < _len; i = ++_i) {
      group = groups[i];
      understand_count = 0;
      for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
        student = group[_j];
        if (student.understands) {
          understand_count += 1;
        }
      }
      if (understand_count === 0) {
        return false;
      }
    }
    return true;
  };

  flag = false;

  count = 0;

  while (flag === false) {
    count += 1;
    reset_input();
    generate_random_groups();
    flag1 = check_understands();
    flag2 = check_noisy();
    flag3 = check_compatability();
    if (flag1 && flag2 && flag3) {
      flag = true;
    }
  }

  console.log('SUCCESS, try ' + count);

  print_results();

  console.log('  Passes noisy test: ' + check_noisy());

  console.log('  Passes understands test: ' + check_understands());

  console.log('  Passes compatability test: ' + check_compatability());

}).call(this);

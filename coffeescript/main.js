// Generated by CoffeeScript 1.6.3
(function() {
  var assign_first_valid, assign_remaining_students, check_if_compatable, get_index_of_next_compatable, get_noisy_count, get_understands, groups, i, initialJSON, instantiate_groups, json, print_results, printable_list, shuffle, stringified, student_count, testArray, _i,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  initialJSON = require('./students.json');

  stringified = JSON.stringify(initialJSON);

  testArray = ['one', 'two', 'three', 'four', 'five'];

  shuffle = function(source_array) {
    var i, item, j, temp, _i, _len;
    for (i = _i = 0, _len = source_array.length; _i < _len; i = ++_i) {
      item = source_array[i];
      j = i + Math.floor(Math.random() * source_array.length - i);
      temp = source_array[j];
      source_array[j] = source_array[i];
      source_array[i] = temp;
    }
    return source_array;
  };

  instantiate_groups = function() {
    /* 
    seeds each of the appropriate number of groups with one student who understands
    */

    var group, i, _i, _j, _len, _ref, _results;
    for (i = _i = 0, _ref = initialJSON.groups; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      groups.push([]);
    }
    _results = [];
    for (_j = 0, _len = groups.length; _j < _len; _j++) {
      group = groups[_j];
      _results.push(group.push(get_understands()));
    }
    return _results;
  };

  get_understands = function() {
    /* 
    returns the first student that understands, removes from the array
    */

    var index, student, _i, _len, _ref;
    _ref = json.students;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      student = _ref[index];
      if (student.understands) {
        json.students.splice(index, 1);
        return student;
      }
    }
  };

  check_if_compatable = function(name, input_group) {
    /*
    Given a name and a list of students, returns true if name is compatable and doesn't create a group with more than two noisy students. Returns false if passed an empty array
    */

    var entry, incompatable_list, noisy_count, student, student_in_question, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    incompatable_list = [];
    for (_i = 0, _len = input_group.length; _i < _len; _i++) {
      student = input_group[_i];
      _ref = student.fights_with;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        entry = _ref[_j];
        incompatable_list.push(entry);
      }
    }
    if (__indexOf.call(incompatable_list, name) >= 0) {
      return false;
    }
    noisy_count = get_noisy_count(input_group);
    _ref1 = json.students;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      student = _ref1[_k];
      if (student.name === name) {
        student_in_question = student;
      }
    }
    if (student_in_question.noisy) {
      noisy_count += 1;
    }
    if (noisy_count > 2) {
      return false;
    }
    return true;
  };

  get_noisy_count = function(input_group) {
    /*
    Returns number of noisy students in input_group
    */

    var noisy, student, _i, _len;
    noisy = 0;
    for (_i = 0, _len = input_group.length; _i < _len; _i++) {
      student = input_group[_i];
      if (student.noisy) {
        noisy += 1;
      }
    }
    return noisy;
  };

  get_index_of_next_compatable = function(input_group) {
    /*
    Given a group of students, returns the index of the next unassigned compatable student.
    If no more compatable students, returns -1
    */

    var i, student, _i, _len, _ref;
    _ref = json.students;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      student = _ref[i];
      if (check_if_compatable(student.name, input_group)) {
        return i;
      }
    }
    return -1;
  };

  assign_first_valid = function(input_group) {
    /*
    Given a list representing a group, assigns the first student that satisfies the criteria of not fighting with anyone in the group and not causing the group to exceed two noisy children. Removes assigned child from available roster. Returns true if successful, false if failed because of lack of compatable students
    */

    var compatable_index;
    compatable_index = get_index_of_next_compatable(input_group);
    if (compatable_index >= 0) {
      input_group.push(json.students[compatable_index]);
      return json.students.splice(compatable_index, 1);
    }
  };

  assign_remaining_students = function() {
    /*
    Assigns one compatable student to each group, if possible
    */

    var group, i, loops_necessary, _i, _results;
    loops_necessary = Math.ceil(student_count / json.groups);
    _results = [];
    for (i = _i = 0; 0 <= loops_necessary ? _i < loops_necessary : _i > loops_necessary; i = 0 <= loops_necessary ? ++_i : --_i) {
      _results.push((function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = groups.length; _j < _len; _j++) {
          group = groups[_j];
          _results1.push(assign_first_valid(group));
        }
        return _results1;
      })());
    }
    return _results;
  };

  print_results = function() {
    /*
    prints remaining students, members of each group
    */

    var group, i, name, names, remaining, remaining_names, student, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _results;
    remaining = [];
    _ref = json.students;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      student = _ref[_i];
      remaining.push(student.name);
    }
    remaining_names = '  Unassigned students remaining: ';
    for (_j = 0, _len1 = remaining.length; _j < _len1; _j++) {
      name = remaining[_j];
      remaining_names += name + ' ';
    }
    console.log(remaining_names);
    _results = [];
    for (i = _k = 0, _len2 = groups.length; _k < _len2; i = ++_k) {
      group = groups[i];
      names = [];
      for (_l = 0, _len3 = group.length; _l < _len3; _l++) {
        student = group[_l];
        names.push(student.name);
      }
      _results.push(console.log('  Group ' + i + ': ' + names));
    }
    return _results;
  };

  printable_list = function(input_group) {
    /*
    Given list of student objects, returns string of names
    */

    var names, student, _i, _len;
    names = [];
    for (_i = 0, _len = input_group.length; _i < _len; _i++) {
      student = input_group[_i];
      names.push(student.name);
    }
    return JSON.stringify(names);
  };

  groups = [];

  json = JSON.parse(stringified);

  student_count = json.students.length;

  for (i = _i = 0; _i < 100; i = ++_i) {
    json = JSON.parse(stringified);
    json.students = shuffle(json.students);
    groups = [];
    instantiate_groups();
    assign_remaining_students();
    if (json.students.length === 0) {
      console.log('SUCCESS on try ' + (i + 1));
      print_results();
      break;
    }
  }

  if (json.students.length !== 0) {
    console.log('Failed to find a valid solution');
  }

}).call(this);
